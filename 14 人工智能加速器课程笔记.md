---
typora-root-url: D:\typora图片总
---

# 08 人工智能加速器课程笔记

## 八、人工智能加速器课程笔记

### 1、verilog基本示例

如异或逻辑  $Y=\bar{A}B+A\bar{B}$

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E5%BC%82%E6%88%96%E9%80%BB%E8%BE%91%E9%97%A8%E7%BB%93%E6%9E%84%E5%9B%BE.jpg)

verilog代码

```verilog
module top (
    input A;
    input B;
    output reg Y;
);
    assign Y=((~A&B)|(A&~B));
endmodule
```

或者:

```verilog
module top (
    input A;
    input B;
    output reg Y;
);
always@(*)
    begin:_anyname_
        reg tp;
        tp=~A&B;
        tp=tp|(A&~B);
        Y=tp;
    end
endmodule
```

创建新的vivado工程，Add sourcefile，编写代码。

使用RTL ANALYSIS 下的Schemtic，查看代码会生成怎样的电路。

### 2、触发器、寄存器、锁存器、缓冲器、存储器

**触发器**（Flip-Flop，简写为FF）：也叫双稳态门。使用最多的是D触发器。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/D%E8%A7%A6%E5%8F%91%E5%99%A8.png) ![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/D%E8%A7%A6%E5%8F%91%E5%99%A8%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg)

时序图中，输出Q的变化相对于上升沿时钟，会有一个时间延迟。

**寄存器：**寄存器是由触发器和门电路构成的。触发器是计算机记忆装置的基本单元，一个触发器能储存一位二进制代码。一个触发器就职一个一位的寄存器，多个触发器就可以组成一个多位的寄存器。

**存储器：**存储器是由大量寄存器组成的，其中每一个寄存器就称为一个存储单元。它可以存放一个有独立意义的二进制代码。

**锁存器：**锁存器不同于触发器，它不在锁存数据时，输出端的信号随输入信号变化，就像信号通过一个缓冲器一样；一旦锁存信号起锁存作用，则数据被锁存，输入信号不起作用。锁存器也称为透明锁存器，指的是不锁存时输出对于输入是透明的。

### 3、关于BRAM 

#### **（1）BRAM时序讲解**

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%20IP.png)                      ![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

​       对于双端口RAM，则为两个端口共同寻址4096空间。其优点是：可以同时读写两个地址的内容。在实际应用中，两个模块可以共享一个BRAM空间。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%E6%97%B6%E5%BA%8F%E5%9B%BE.png)

a. 当使能信号ena=1，写使能wea=1，此时在上升沿，将dina的数据写入到对应的地址中，这里为将数据B写到地址A中；

b. 当使能信号ena=1，写使能wea=0，此时在上升沿，从当前地址C读数据到douta

**注：若在当前时钟发生了读行为，可能在下个时钟或者下下个时钟等有效，则引出参数read latency,**

​       **若下个时钟有效，则read latency=1；若下下个时钟有效，则read latency=2。**

       **通常的存储器latency=1**

​       在vivado中对BRAM IP进行设置时，如图，当勾选Primitives Output Register选项时，Read Latency变为2，不勾选时，为1。推荐使用Read Latency=1的设置，因为如果要将设计变成芯片，厂商提供的SRAM都是Read Latency=1的。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%20IP%E8%AE%BE%E7%BD%AE.png) ![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%20IP%E8%AE%BE%E7%BD%AE2.png)

 与BRAM IP等价的代码：

```verilog
module mem(
	input clk,
	input en,
    input we,
    input [5:0] addr,//地址位宽为6，则可以得到寻址空间为2的6次幂为64
    input [16-1:0] din,
    output reg [16-1:0] dout
);
    reg [16-1:0]mem[63:0];//这是一个名称为men的寄存器类型的端口，此寄存器的深度是64（64个），每个数据的位宽为16
    always@(posedge clk)
        if (en & we)
            mem[addr]<=din;
    always@(posedge clk)
        if (en)
            dout<=mem[addr];
endmodule      
```

​       

- ​       如果使用ASIC的综合工具（如DC）综合这段代码，则真的会用16x64个D触发器实现，浪费资源，但是用D触发器实现，其Read Latency可以为0，即有读请求时，dout可以立即得到这个数据。

- ​       如果使用FPGA的综合工具（如vivado)综合这段代码， 则会自动使用Block RAMs（SRAM）来实现。按照这种方式实现，当发生读请求时，dout会在下一个时钟得到想要的数据。

**在vivado中实际尝试：**

将上面的代码添加到工程中，然后进行综合实现，得到报告Project Summary。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%E7%BB%BC%E5%90%88%E6%8A%A5%E5%91%8A.png)

​       可以看出，vivado在实现此代码时，自动调用了BRAM资源，且用了0.5个（如图，此硬件平台上共有1030个BRAM可用，因为每个BRAM由两个18kb组成36kb，所以最少可以使用半个）。

​        此时，再点击vivado中SYNTHESIS下的Schematic，查看原理图（这个原理图和RTL ANALYSIS下的原理图不同，此图是经综合后优化过的图）。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%E5%8E%9F%E7%90%86%E5%9B%BE.png)

**总结：若要使用BRAM，既可以直接从IP目录里调用IP，也可以通过verilog代码，用vivado将其自动映射到BRAM上**

#### **（2）BRAM IP 模式选择**

对于BRAM IP核，还可以对其进行其他配置：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%20IP%E8%AE%BE%E7%BD%AE3.png) 

如图，在Memory Type中，可配置的选项有：单端口RAM、简单双端口RAM、真双端口RAM、单端口只读存储器ROM、双端口只读存储器ROM。

- 对于真双端口RAM，两个端口均可以进行读写。即在一个周期内，可以同时读两个数据，可以同时写两个数据，也可以读一个写一个；而对于简单双端口RAM，只能固定一个端口为读，另一个端口写。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E7%9C%9F%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM.png)                     ![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E7%AE%80%E5%8D%95%E5%8F%8C%E7%AB%AF%E5%8F%A3RAM.png)

- 对于只读存储器，其是将ROM内部已经事先存好的数据读出来。读数据时，也要经过Read Latency的延迟。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/ROM1.png) ![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/ROM2.png)

其对应的代码可以写成：

```verilog
module ROM_step_1(
	input clk,
    input en,
    input [6-1:0] addr
    output reg [16-1:0]dout
);
    always@(posedge clk)
    	beign
        if(en)
            case(addr)
                'd0:dout<=16'b0000000000000001;
                'd1:dout<=16'b0000000000000010;
                'd2:dout<=16'b0000000000000100;
                ....
                'd31:dout<=16'b00000000000001000;
         end
endmodule          
```

#### **（3）BRAM的应用实例**

背景：如图是FFT快速傅里叶变换的流程图，左侧是输入时域数据，右侧是输出的频谱，可以看到，右侧的频谱输出是乱序的，此时可以应用RAM设计一个模块调整其顺序。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/FFT%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

模块设计：假设FFT模块输出为64个乱序的数据，现在要把它们存进RAM的对应地址里，然后再按顺序将数据依次读出来。

​                 下图是模块整体构造，需要的端口有：写端口、写有效（为1时可以写）、读端口、读有效

​                ![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%E5%BA%94%E7%94%A81.png)

具体实现：首先应该有读和写两个计数器，最多可以从0计数到65，分别记录读写的数量。没写入一个数据，写计数器自增1。             

​                 当写计数器自增到65时会跳变到0，此时读计数器开始计数。即时序图可以简单表示为：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%E5%BA%94%E7%94%A82.png)

​                  先将16个数据写进来，然后再依次读出去，然后再写。但如果实际中，上一次存进来的数据，还没有读出完，下一次的数据又存进来。**为了解决这个问题，可以用两个存储器，进行类似于乒乓操作，轮流读写**。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/BRAM%E5%BA%94%E7%94%A83.png) 在读写的时候，分别有一个判断位，选择使用哪个RAM。

#### （4）SRAM与DRAM

​	最基本的，一般DRAM用作内存比较多（如电脑上的DDR3内存），SRAM用作cache比较多。**注：FPGA中的Block RAM属于SRAM存储方式**。

​	从名字上看，SRAM与DRAM的区别只在于一个是静态一个是动态。由于SRAM不需要刷新电路就能够保存数据，所以具有静止存取数据的作用。而DRAM则需要不停地刷新电路（预充电），否则内部的数据将会消失。而且不停刷新电路的功耗是很高的，在我们的PC待机时消耗的电量有很大一部分都来自于对内存的刷新。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/SRAM%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png)                             ![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DRAM%E7%BB%93%E6%9E%84%E5%9B%BE.png)

​            SRAM的基本单元结构图                                                   DRAM的基本单元结构图

​	常用的SRAM集成芯片：6116(2K×8位)，6264(8K×8位)，62256(32K×8位)，2114(1K×4位)。

​	SRAM存储一位数据需要用6个晶体管，而DRAM只需要花一个电容和一个晶体管。cache追求的是速度，所以选用SRAM，而内存则追求容量所以选择能够在相同空间中存放更多内容并且造价相对低廉的DRAM。

​	关于DRAM需要不断刷新的原因，是因为DRAM的数据实际上是存在电容里的。而电容放久了，内部的电荷就会越来越少，对外就形成不了电位的变化。而且当对DRAM进行读操作的时候需要将电容与外界形成回路，通过检查是否有电荷流进或流出来判断该bit是1还是0。所以无论怎样，在读操作中我们都破坏了原来的数据。所以在读操作结束后需要将数据写回DRAM中。在整个读或者写操作的周期中，计算机都会进行DRAM的刷新，通常是刷新的周期是4ms-64ms。

​	关于SRAM和DRAM的寻址方式也有所不同。虽然通常我们都认为内存像一个长长的数组呈一维排列，但实际上内存是以一个二维数组的形式排列的，每个单元都有其行地址和列地址，当然cache也一样。而这两者的不同在于对于容量较小的SRAM，我们可以将行地址和列地址一次性传入到SRAM中，而如果我们对DRAM也这样做的话，则需要很多很多根地址线（容量越大，地址越长，地址位数越多）。所以我们选择分别传送行地址和列地址到DRAM中。先选中一整行，然后将整行数据存到一个锁存器中，等待列地址的传送然后选中所需要的数据。这也是为什么SRAM比DRAM快的原因之一。

DRAM讲解链接：

DRAM之最通俗易懂的图文解说：https://blog.csdn.net/c243320761/article/details/80980866

DRAM内存介绍：https://blog.csdn.net/qq_39759656/article/details/81672895

DRAM内存原理系列：https://blog.csdn.net/zhiwensun/article/details/41799317

DRAM的结构之概括系列：https://blog.csdn.net/sundingh/article/details/52782242

关于SRAM和DRAM读写时序的差异：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/SRAM%E5%86%99%E6%97%B6%E5%BA%8F.png)  ![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DRAM%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

- 对于SRAM，读写速度较快，如当有写请求时，每个cycle都可以写入数据。
- 对于DRAM：

​	DRAM内部分成若干BANK块，读写不同BANK里的数据，需要单独进行刷新操作（预先充电）。由于频繁进行刷新操作，所以当有读请求时，可能会经过10-30个cycle（预充电）才能进行写数据操作，即DRAM读写数据很慢。

​	因为DRAM数据读写比较慢，为了防止与DRAM搭配的运算单元可以接收到所有的数据，所以采用valid、ready握手模式。

​	为了改善这种读写很慢的状态，可以采用outstanding模式（通道分离）。首先，如果在同一个BANK内读写数据，只充电一次就行。所以可以将写请求和写数据两条通道分开，即不停地发一个个写请求，再依次写入数据，如图：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/outstanding.png)

​	**outstanding模式**的效率还不是很高，DRAM还支持一种burst模式。

​	在**burst模式**中，只需要一次写请求就可以写入多个数据。具体的，在写请求中，除了valid和ready握手信号、addr地址信号以外，还有**数据长度len信号**，表明要写入数据的数量。例如，在写请求中addr=100，len=16，则经过十几个周期后要写入数据时，会从地址100开始写入，依次向地址101、102直到115写入数据。

​	将通道分离和burst模式结合起来，可以使DRAM达到一个比较高的效率。

**注**：读存储器的情况也一样，在SRAM中，读请求发生后会经1或2个read latency再读出数据；在DRAM中，读请求发生后，还是会经过10-30个周期，才会读出数据。

### 4、AXI总线

​	**关于总线、接口和协议**：总线是一组传输通道，是各种逻辑器件构成的传输数据的通道，一般由由数据线、地址线、控制线等构成。接口是一种连接标准，又常常被称为物理接口。协议就是传输数据的规则。

#### （1）AXI总线概述

##### 1、三种总线基本说明

​	AXI（Advanced eXtensible Interface）本是由ARM 公司提出的一种总线协议，Xilinx从6 系列的FPGA 开始对AXI 总线提供支持，此时AXI 已经发展到了AXI4 这个版本，所以现在用到Xilinx 的软件的时候看到的都是“AIX4”的IP，如Vivado 打包一个AXI IP的时候，看到的都是Create a new AXI4 peripheral。

​	在ZYNQ中支持三种AXI总线，拥有三种AXI接口，当然用的都是AXI协议。其中三种AXI总线分别为：

- **AXI4（full）：**（For high-performance memory-mapped requirements.）主要面向高性能地址映射通信的需求，是面向地址映射的接口，在单地址传输的情况下允许最大256轮（时钟周期）的数据突发burst传输，拥有最完整的功能。
- **AXI4-Lite：**（For simple, low-throughput memory-mapped communication ）是一个轻量级的地址映射单次传输接口，占用很少的逻辑单元。这是精简版的AXI4协议，目的是为了与控制寄存器风格的接口组件进行通信并允许建立简单的组件接口。
- **AXI4-Stream：**（For high-speed streaming data.）面向高速流数据传输；相比AXI4总线去掉了地址项，允许无限制的数据突发传输规模，无需考虑地址映射。

##### 2、AXI4( full )与AXI4-Lite总线对比

AXI4总线和AXI4-Lite总线均包含5个不同的通道，分别为：

- **读地址通道**
- **写地址通道**
- **读数据通道**
- **写数据通道**
- **读响应通道**

数据可以在主从设备间同步进行双向传输，并且数据数据传输大小可以改变。

AXI4将数据传输的突发长度限制为最大256，AXI4-Lite每次传输仅运输传输一个数据。

**AXI4-Lite接口和AXI4接口类似，但是不支持AXI4的突发传输模式。**

下面分别是读操作和写操作的通道结构：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E8%AF%BB%E9%80%9A%E9%81%93%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E5%86%99%E9%80%9A%E9%81%93%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

**写操作比读操作多一个应答信号的原因：**

​	写应答，主要是回复主机你这个写过程是没有问题的。而主机在读取数据时，从机可以直接通过读数据通道给主机反馈信息，因此就没有必要再来开辟一个单独的应答通道了。

**AXI4 ( full ) 和AXI4-Lite接口信号**：

:one:  **全局信号**

| 信号名  | AXI4               | AXI4-Lit         |
| ------- | ------------------ | ---------------- |
| ACLK    | 全局时钟           | 全局时钟         |
| ARESETN | 全局复位，低有效。 | 全局复位，低有效 |

:two:  **写地址通道信号**

| 信号名   | 源   | AXI4                                                         | AXI4-Lit |
| -------- | ---- | ------------------------------------------------------------ | -------- |
| AWID     | 主   | 写地址ID。这个信号用于写地址信号组的标记。                   | 不支持   |
| AWADDR   | 主   | 写地址。写地址给出突发数据传输的第一个传输地址。             |          |
| AWLEN    | 主   | 突发长度。给出突发传输中准确的传输个数。支持INCR和WRAP传输模式。 | 不支持   |
| AWSIZE   | 主   | 突发大小。这个信号用于确定突发传输中每个传输的大小。         | 不支持   |
| AWBURST  | 主   | 突发类型。该信息与突发大小信息一起，表示在突发过程中，地址如何应用于每个传输。支持INCR和WRAP传输模式。 | 不支持   |
| AWLOCK   | 主   | 锁类型。该信号提供了关于传输原子特性的额外信息（普通或互斥访问）。 | 不支持   |
| AWCACHE  | 主   | 缓存类型，建议值为0011。                                     |          |
| AWPROT   | 主   | 保护类型，建议值为000。                                      |          |
| AWQOS    | 主   | QoS标识符，xilinx AXI4不支持。                               | 不支持   |
| AWREGION | 主   | 用于每个写操作的地址通道上的域标识符。                       | 不支持   |
| AWUSER   | 主   | xilinx AXI4不支持。                                          | 不支持   |
| AWVALID  | 主   | 写地址有效信号。为高指示地址有效。                           |          |
| AWREADY  | 从   | 写地址准备信号。为高表示从设备空闲，准备接收地址；为低表示从设备忙。 |          |

:three:  **写数据通道信号**

| 信号名 | 源   | AXI4                                                         | AXI-Lite             |
| ------ | ---- | ------------------------------------------------------------ | -------------------- |
| WDATA  | 主   | 写数据，32位到1024位宽                                       | 只支持32位宽         |
| WSTRB  | 主   | 写字节选通，用于表示更新存储器的字节通道，对于数据总线的每8位数据有一位写选通信号。 | 从设备端可选择忽略。 |
| WLAST  | 主   | 写最后一个数据指示信号。表示突发传输中的最后一个数据。       | 不支持               |
| WUSER  | 主   | xilinx AXI4不支持。                                          | 不支持               |
| WVALID | 主   | 写有效。为高指示数据有效。                                   |                      |
| WREADY | 从   | 写准备。为高表示从设备空闲，准备接收数据；为低表示从设备忙。 |                      |

:four:  **写响应通道信号**

| 信号名 | 源   | AXI4                                                         | AXI-Lite         |
| ------ | ---- | ------------------------------------------------------------ | ---------------- |
| BID    | 从   | 响应ID。写响应识别标记，BID值必须匹配AWID值。                | 不支持           |
| BRESP  | 从   | 写响应。该信号表示写状态，可允许相应的表示为OKAY\EXOKAY\SLVERR\DECERR。 | EXOKAY状态不支持 |
| BUSER  | 从   | xilinx AXI4不支持。                                          | 不支持           |
| BVALID | 从   | 写响应有效。为高指示响应数据有效。                           |                  |
| BREADY | 主   | 写响应准备。为高表示主设备空闲，准备接收写响应；为低表示主设备忙。 |                  |

:five:  **读地址通道信号** 

| 信号名   | 源   | AXI4                                                         | AXI-Lite |
| -------- | ---- | ------------------------------------------------------------ | -------- |
| ARID     | 主   | 读地址ID。这个信号用于读地址信号组的标记。                   | 不支持   |
| ARADDR   | 主   | 读地址。读地址给出突发数据传输的第一个传输地址。             |          |
| ARLEN    | 主   | 突发长度。给出突发传输中准确的传输个数。支持INCR和WRAP传输模式。 | 不支持   |
| ARSIZE   | 主   | 突发大小。这个信号用于确定突发传输中每个传输的大小。         | 不支持   |
| ARBURST  | 主   | 突发类型。该信息与突发大小信息一起，表示在突发过程中，地址如何应用于每个传输。支持INCR和WRAP传输模式。 | 不支持   |
| ARLOCK   | 主   | 锁类型。该信号提供了关于传输原子特性的额外信息（普通或互斥访问）。 | 不支持   |
| ARCACHE  | 主   | 缓存类型，建议值为0011。                                     |          |
| ARPROT   | 主   | 保护类型，建议值为000。                                      |          |
| ARQOS    | 主   | QoS标识符，xilinx AXI4不支持。                               | 不支持   |
| ARREGION | 主   | 用于每个读操作的地址通道上的域标识符。                       | 不支持   |
| ARUSER   | 主   | xilinx AXI4不支持。                                          | 不支持   |
| ARVALID  | 主   | 读地址有效信号。为高指示地址有效。                           |          |
| ARREADY  | 从   | 读地址准备信号。为高表示从设备空闲，准备接收地址；为低表示从设备忙。 |          |

:six:  **读数据通道信号​**  

| 信号名 | 源   | AXI4                                                         | AXI-Lite         |
| ------ | ---- | ------------------------------------------------------------ | ---------------- |
| RID    | 从   | 读ID标记，该信号是读数据信号组标记，由从设备产生RID，RID必须和读交易中的ARID匹配。 | 不支持           |
| RDATA  | 从   | 读数据。32位到1024位宽                                       | 只支持32位宽     |
| RRESP  | 从   | 读响应。该信号表示读状态，可允许相应的表示为OKAY\EXOKAY\SLVERR\DECERR。 | EXOKAY状态不支持 |
| RLAST  | 从   | 读最后一个数据指示信号。表示突发传输中的最后一个数据。       | 不支持           |
| RUSER  | 从   | xilinx AXI4不支持。                                          | 不支持           |
| RVALID | 从   | 读有效。为高指示数据有效。                                   |                  |
| RREADY | 主   | 读准备。为高表示主设备空闲，准备接收数据；为低表示主设备忙。 |                  |

**AXI4总线和AXI4-Lite总线的信号的命名特点为：**

读地址信号都是以AR开头（A：address；R：read）
写地址信号都是以AW开头（A：address；W：write）
读数据信号都是以R开头（R：read）
写数据信号都是以W开头（W：write）
应答型号都是以B开头（B：back（answer back））





**AXI4和AXI4-Stream对比总结：**

==**通常在神经网络加速器设计中，用AXI4-Lite总线进行对寄存器的配置；用AXI总线，通过AXI-HP接口，对DDR进行数据的读写。**==    

**1、相同点：** 

都是有五个数据通道；

二者的延迟latency相同，即如果访问有延迟的设备，当读写请求发生后，会经过若干周期的延迟，再进行数据的读写。

**2、不同点：** 

|                                                    | AXI4 | AXI4-Lite |
| :------------------------------------------------- | ---- | --------- |
| burst突发传输模式                                  | 支持 | 不支持    |
| outstanding模式 （不停发出读写请求，前面DRAM讲过） | 支持 | 不支持    |
| 乱序                                               | 支持 | 不支持    |

**AXI4在读写地址通道中，主要比AXI4-Lite增加了ID、LEN和SIZE信号；在读写数据通道中，主要增加了LAST和ID信号。** 



**关于乱序（ID）：** 

AXI4总线的读写命令中有ID信号，给每次的读写都加上标记。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E4%B9%B1%E5%BA%8F%E8%AF%BB%E5%86%99.png)

   其中的1和2，为读写命令的ID。若支持乱序模式，则不必等数据1完全读写完毕即可对数据2进行操作。

**读写命令中ID的应用 : CROSSBAR( CB )**

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E4%B9%B1%E5%BA%8F%E5%BA%94%E7%94%A8.png)

如图，若要从DDR中分别读取权重、特征和偏置数据，则可以根据ID号，判断每次从DDR读出的数据，属于三者中的哪一类。









​                                                 

##### 3、关于AXI4-Stream总线                                                           

​	

**AXI4-Stream总线的接口信号：**

| 信号名 | 源   | 默认值           | 功能                                                         |
| ------ | ---- | ---------------- | ------------------------------------------------------------ |
| TVALID | No   | N/A              | Stream读写数据有效。为高指示数据有效。                       |
| TREADY | Yes  | 1                | Stream读写读准备。为高表示对端设备空闲，准备接收数据；为低表示对端设备忙。 |
| TDATA  | Yes  | 0                | Stream读写数据，8到4096位宽。                                |
| TSTRB  | Yes  | 同TKEEP，否则为1 | 字节选通信号。用于表示更新存储器的字节通道，对于数据总线的每8位数据有一位选通信号。 |
| TKEEP  | Yes  | 1                | 字节选通信号。TKEEP未被确认的那些相关的字节是空字节，可以从数据流中去除。 |
| TLAST  | Yes  | 0                | 表明包的边界。                                               |
| TID    | Yes  | 0                | 数据流标识符。                                               |
| TDEST  | Yes  | 0                | 数据流路由信息。                                             |
| TUSER  | Yes  | 0                | 用户定义的边带信息，这些信息能伴随数据流进行发送。           |

**对于AXI4-Stream总线命名**：除了总线时钟和总线复位，其他的信号线都是以T字母开头，后面跟上一个有意义的单词。

#### （2）AXI接口概述

三种AXI接口分别是：

- **AXI-GP接口（4个）**：是通用的AXI接口，包括两个32位主设备接口和两个32位从设备接口，用该接口可以访问PS中的片内外设。
- **AXI-HP接口（4个）**：是高性能/带宽的标准的接口，PL模块作为主设备连接（从下图中箭头可以看出）。主要用于PL访问PS上的存储器（DDR和On-Chip RAM）
- **AXI-ACP接口（1个）**：是ARM多核架构下定义的一种接口，中文翻译为加速器一致性端口，用来管理DMA之类的不带缓存的AXI外设，PS端是Slave接口。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/ZYNQ%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E5%9B%BE.jpg)

==**注：** PS与PL之间的接口（AXI-GP接口，AXI-HP接口以及AXI-ACP接口）却**只支持AXI-Lite和AXI协议这两种总线协议**。也就是说PL这边的**AXI-Stream的接口是不能直接与PS对接的**，需要经过AXI4或者AXI4-Lite的转换。比如后面将用到的VDMA IP ，它就实现了在**PL内部AXI4到AXI-Stream的转换**，VDMA利用的接口就是AXI-HP接口。== 

#### （3）AXI协议概述   

​	总的来说，AXI总线协议的两端可以分为分为主（master）、从（slave）两端，他们之间一般需要通过一个**AXI Interconnect**相连接，作用是提供将**一个或多个AXI主设备连接到一个或多个AXI从设备**的一种交换机制。由于**AXI支持乱序发送**，乱序发送需要主机的ID信号支撑，而不同的主机发送的ID可能相同，而AXI Interconnect解决了这一问题，他会对不同主机的ID信号进行处理让ID变得唯一。当我们添加了zynq以及带AXI的IP后再进行自动连线时vivado会自动添加上这个IP。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/AXI%20Interconnet.jpg)

 	AXI协议将读地址通道，读数据通道，写地址通道，写数据通道，写响应通道分开，各自通道都有自己的握手协议。每个通道互不干扰却又彼此依赖。这也是AXI高效的原因之一。

**1、AXI协议之握手**：

AXI4 所采用的是一种READY，VALID 握手通信机制，简单来说主从双方进行数据通信前，有一个握手的过程。传输源产生VLAID 信号来指明何时数据或控制信息有效。而目地源产生READY 信号来指明已经准备好接受数据或控制信息。**传输发生在VALID和READY 信号同时为高的时候**。VALID 和READY 信号的出现有三种关系：

- VALID 先变高READY 后变高。时序图如下（在箭头处信息传输发生）：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/AXI%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE1.png)

- READY 先变高VALID 后变高。时序图如下：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/AXI%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE2.png)

- VALID 和READY 信号同时变高。时序图如下：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/AXI%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE3.png)

**需要强调的是，AXI的五个通道，每个通道都有握手机制**。

**2、突发式读写（针对AXI4总线）**：

- 突发式读时序图如下：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E7%AA%81%E5%8F%91%E5%BC%8F%E8%AF%BB%E6%97%B6%E5%BA%8F%E5%9B%BE.png)

a. 当地址出现在地址总线之后，传输的数据将出现在读数据通道上。**且读请求发生后，要经过几个周期延迟，进行读数据操作**。

b. 地址通道和数据通道有其单独的VALID和READY信号。

c. 为了表明一次突发式读写的完成，设备用**RLAST 信号来表示最后一个被传输的数据**。

- 突发式写时序图如下：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E7%AA%81%E5%8F%91%E5%BC%8F%E5%86%99%E6%97%B6%E5%BA%8F%E5%9B%BE.png)

这一过程的开始时，主机（master）发送地址和控制信息到写地址通道中，然后主机发送每一个写数据到写数据通道中。当主机发送最后一个数据时，WLAST 信号就变为高。当设备（slave）接收完所有数据之后他将一个写响应发送回主机来表明写事务完成。

### 5、AXI4-Lite详细操作

**AXI4-Lite总线的接口信号为：** 

（1）读地址通道，包含ARVALID, ARADDR, ARREADY信号；
（2）读数据通道，包含RVALID, RDATA, RREADY, RRESP信号；
（3）写地址通道，包含AWVALID，AWADDR, AWREADY信号；
（4）写数据通道，包含WVALID, WDATA，WSTRB, WREADY信号；
（5）写应答通道，包含BVALID, BRESP, BREADY信号；
（6）系统通道，包含：ACLK，ARESETN信号。

#### （1）AXI4-Lite源码

- **要查看AXI-Lite的源码，需要先自定义一个AXI-Lite的IP（在vivado2016.4环境中）**：

菜单栏->Tools->Creat and Package New IP：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E8%87%AA%E5%AE%9A%E4%B9%89IP%E6%B5%81%E7%A8%8B1.jpg)

选择Next：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E8%87%AA%E5%AE%9A%E4%B9%89IP%E6%B5%81%E7%A8%8B2.png)

选择Create AXI4 Peripheral，然后Next：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E8%87%AA%E5%AE%9A%E4%B9%89IP%E6%B5%81%E7%A8%8B3.png)

默认，选择Next：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E8%87%AA%E5%AE%9A%E4%B9%89IP%E6%B5%81%E7%A8%8B4.png)

注意这里接口类型选择Lite，选择Next：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E8%87%AA%E5%AE%9A%E4%B9%89IP%E6%B5%81%E7%A8%8B5.png)

选择Edit IP，点击Finish：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E8%87%AA%E5%AE%9A%E4%B9%89IP%E6%B5%81%E7%A8%8B6.png)

此后，Vivado会新建一个工程，专门编辑该IP，通过该工程，我们就可以看到Vivado为我们生成的AXI-Lite的操作源码：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E8%87%AA%E5%AE%9A%E4%B9%89IP%E6%B5%81%E7%A8%8B7.jpg)

- **AXI-Lite源码分析**：

  **1、首先是信号定义：**

```verilog
		input wire  S_AXI_ACLK,
		input wire  S_AXI_ARESETN,
		input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,
		input wire [2 : 0] S_AXI_AWPROT,
		input wire  S_AXI_AWVALID,
		output wire  S_AXI_AWREADY,
		input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,
		input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,
		input wire  S_AXI_WVALID,
		output wire  S_AXI_WREADY,
		output wire [1 : 0] S_AXI_BRESP,
		output wire  S_AXI_BVALID,
		input wire  S_AXI_BREADY,
		input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,
		input wire [2 : 0] S_AXI_ARPROT,
		input wire  S_AXI_ARVALID,
		output wire  S_AXI_ARREADY,
		output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,
		output wire [1 : 0] S_AXI_RRESP,
		output wire  S_AXI_RVALID,
		input wire  S_AXI_RREADY
```

这些读写信号在AXI总线概述中已经详细介绍过。

Vivado生成的AXI-Lite的操作源码，是一个例子，只需要读懂他，然后稍加修改，就可以为我们所用。

**2、关于WDATA写数据相关的代码：**

```verilog
always @( posedge S_AXI_ACLK )
	begin
	  if ( S_AXI_ARESETN == 1'b0 )
	    begin
	      slv_reg0 <= 0;
	      slv_reg1 <= 0;
	      slv_reg2 <= 0;
	      slv_reg3 <= 0;
	    end 
	  else begin
	    if (slv_reg_wren)
	      begin
	        case ( axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
	          2'h0:
	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
	                // Respective byte enables are asserted as per write strobes 
	                // Slave register 0
	                slv_reg0[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
	              end  
	          2'h1:
	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
	                // Respective byte enables are asserted as per write strobes 
	                // Slave register 1
	                slv_reg1[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
	              end  
	          2'h2:
	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
	                // Respective byte enables are asserted as per write strobes 
	                // Slave register 2
	                slv_reg2[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
	              end  
	          2'h3:
	            for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
	              if ( S_AXI_WSTRB[byte_index] == 1 ) begin
	                // Respective byte enables are asserted as per write strobes 
	                // Slave register 3
	                slv_reg3[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
	              end  
	          default : begin
	                      slv_reg0 <= slv_reg0;
	                      slv_reg1 <= slv_reg1;
	                      slv_reg2 <= slv_reg2;
	                      slv_reg3 <= slv_reg3;
	                    end
	        endcase
	      end
	  end
	end   
```



 ==当PS那边向AXI4-Lite总线写数据时，PS这边负责将数据接收到寄存器slv_reg。而slv_reg寄存器有0~3共4个。至于赋值给哪一个由axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]决定，根据宏定义其实就是由axi_awaddr[3:2] （写地址中不仅包含地址，而且包含了控制位，这里的[3:2]就是控制位）决定赋值给哪个slv_reg。==   

​	PS调用写函数时，如果不做地址偏移的话，axi_awaddr[3:2]的值默认是为0的，比如，若自定义的IP的地址被映射为0x43C00000，那么我们 **Xil_Out32 ( 0x43C00000 , Value )**写的就是slv_reg0的值。如果地址偏移4位，如
**Xil_Out32(0x43C00000 + 4,Value)**  写的就是slv_reg1的值，依次类推。

​	在ps的头文件里可以看到我们**自定义的IP的地址是有范围的**。理论上只要基地址+ 偏移量不要超过HIGHADDR即可。

**#define XPAR_MYIPFREQUENCY_0_S00_AXI_BASEADDR 0x43C00000**
**#define XPAR_MYIPFREQUENCY_0_S00_AXI_HIGHADDR 0x43C0FFFF**



此处单独分析slv_reg0的代码（可以推广到其他寄存器）：

```verilog
 for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
     //C_S_AXI_DATA_WIDTH的宏定义的值为32，即数据位宽
 	if ( S_AXI_WSTRB[byte_index] == 1 ) begin
        //S_AXI_WSTRB是写选通信号，S_AXI_WDATA是写数据信号。
		 slv_reg0[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
        /*
			当byte_index = 0的时候这句话就等价于：
			slv_reg0[7:0] <= S_AXI_WDATA[7:0];
			当byte_index = 1的时候这句话就等价于：
			slv_reg0[15:8] <= S_AXI_WDATA[15:8];
			当byte_index = 2的时候这句话就等价于：
			slv_reg0[23:16] <= S_AXI_WDATA[23:16];
			当byte_index = 3的时候这句话就等价于：
			slv_reg0[31:24] <= S_AXI_WDATA[31:24];
        */
	      end  
//只有当写选通信号为1时，它所对应S_AXI_WDATA的字节才会被读取。
```



**3、关于RDATA读数据代码：**

```verilog
// Output register or memory read data
	always @( posedge S_AXI_ACLK )
	begin
	  if ( S_AXI_ARESETN == 1'b0 )
	    begin
	      axi_rdata  <= 0;
	    end 
	  else
	    begin    
	      // When there is a valid read address (S_AXI_ARVALID) with 
	      // acceptance of read address by the slave (axi_arready), 
	      // output the read dada 
	      if (slv_reg_rden)
	        begin
	          axi_rdata <= reg_data_out;     // register read data
	        end   
	    end
	end    
```

由此代码可知，当PS读取数据时，程序会把reg_data_out复制给axi_rdata（RADTA读数据）。继续追踪reg_data_out：

```verilog
always @(*)
	begin
	      // Address decoding for reading registers
	      case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
	        2'h0   : reg_data_out <= slv_reg0;
	        2'h1   : reg_data_out <= slv_reg1;
	        2'h2   : reg_data_out <= slv_reg2;
	        2'h3   : reg_data_out <= slv_reg3;
	        default : reg_data_out <= 0;
	      endcase
	end
```

和前面分析的一样此时通过判断axi_awaddr[3:2]的值来判断将那个值给reg_data_out上，同样当PS调用读取函数时，这里axi_awaddr[3:2]默认是0，所以我们只需要把slv_reg0替换成我们自己数据，就可以让PS通过总线读到我们提供的数据。



**注**： **AXI4-lite总线的速度比较慢，其slave一般是寄存器。于代码对应，每个寄存器的数据位宽为32，用4个字节表示。** 

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/AXI_lite%E5%8D%8F%E8%AE%AE1.png)

**4、对原代码的应用**

- 若想读AXI4-Lite总线上的数据（**即读取主机向从机写入的数据**），此时只需要关注slv_reg的数据，可以在原程序中添加代码，例如：

```verilog
reg [11:0]rlcd_rgb;
always @( posedge S_AXI_ACLK )
begin
	if ( S_AXI_ARESETN == 1'b0 )
		begin
			rlcd_rgb <= 12'd0;
		end
	else
		begin
			rlcd_rgb <= slv_reg0[11:0];
		end
end
assign lcd_rgb = rlcd_rgb;
```

- 若想对AXI4_Lite信号写数据时（**即抓取主机读取从机的数据**），此时只需要修改对reg_data_out的赋值，如：

```verilog
//写总线测试修改！！！！！！！！！
wire[31:0]wlcd_xy;// = {10'd0,lcd_xy};
assign wlcd_xy = {10'd0,lcd_xy};
assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;
always @(*)
begin
// Address decoding for reading registers
	case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
	2'h0 : reg_data_out <= wlcd_xy;//slv_reg0;
	2'h1 : reg_data_out <= slv_reg1;
	2'h2 : reg_data_out <= slv_reg2;
	2'h3 : reg_data_out <= slv_reg3;
	default : reg_data_out <= 0;
	endcase
end
```



#### （2）仿真AXI4-Lite信号

此工程目的是对AXI4-Lite信号进行仿真，需要将以下三个文件添加到仿真目录下：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E4%BB%BF%E7%9C%9F1.png)

（**注：仿真时，将所有相关的文件添加到vivado中的Simulation Sources中，一般将testbench文件作为顶层文件** ）

:one: 基于AXI4-Lite总线的slave文件dut_axi_lite_slave.v

首先将**AXI_S_Slave_Generator.pl** 文件拷贝到linux系统下，然后依次执行以下命令来生成一个满足AXI-Lite总线的从机：

**chmod a+x AXI_S_Slave_Generator.pl**  （修改此文件的操作权限）

**perl AXI_S_Slave_Generator.pl** 

perl是一种解释型脚本语言。执行此命令，系统会提示输入模块名称（此处为AXI_LITE_SLAVE）和寄存器数量（16）。输入之后，会生成 dut_axi_lite_slave.v文件（这里取决于输入的模块名）

```verilog
`timescale 1 ns / 1 ps

module dut_axi_lite_slave #
(
	parameter integer C_S_AXI_DATA_WIDTH	= 32,
	parameter integer C_S_AXI_ADDR_WIDTH	= 6
)
(
	input wire  S_AXI_ACLK,
	input wire  S_AXI_ARESETN,
	input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_AWADDR,
	input wire [2 : 0] S_AXI_AWPROT,
	input wire  S_AXI_AWVALID,
	output wire  S_AXI_AWREADY,
	input wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_WDATA,
	input wire [(C_S_AXI_DATA_WIDTH/8)-1 : 0] S_AXI_WSTRB,
	input wire  S_AXI_WVALID,
	output wire  S_AXI_WREADY,
	output wire [1 : 0] S_AXI_BRESP,
	output wire  S_AXI_BVALID,
	input wire  S_AXI_BREADY,
	input wire [C_S_AXI_ADDR_WIDTH-1 : 0] S_AXI_ARADDR,
	input wire [2 : 0] S_AXI_ARPROT,
	input wire  S_AXI_ARVALID,
	output wire  S_AXI_ARREADY,
	output wire [C_S_AXI_DATA_WIDTH-1 : 0] S_AXI_RDATA,
	output wire [1 : 0] S_AXI_RRESP,
	output wire  S_AXI_RVALID,
	input wire  S_AXI_RREADY
);

reg [C_S_AXI_ADDR_WIDTH-1 : 0] 	axi_awaddr;
reg  	axi_awready;
reg  	axi_wready;
reg [1 : 0] 	axi_bresp;
reg  	axi_bvalid;
reg [C_S_AXI_ADDR_WIDTH-1 : 0] 	axi_araddr;
reg  	axi_arready;
reg [C_S_AXI_DATA_WIDTH-1 : 0] 	axi_rdata;
reg [1 : 0] 	axi_rresp;
reg  	axi_rvalid;

localparam integer ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1;
localparam integer OPT_MEM_ADDR_BITS = 4-1;

wire	 slv_reg_rden;
wire	 slv_reg_wren;
reg [C_S_AXI_DATA_WIDTH-1:0]	 reg_data_out;
integer	 byte_index;

assign S_AXI_AWREADY	= axi_awready;
assign S_AXI_WREADY	= axi_wready;
assign S_AXI_BRESP	= axi_bresp;
assign S_AXI_BVALID	= axi_bvalid;
assign S_AXI_ARREADY	= axi_arready;
assign S_AXI_RDATA	= axi_rdata;
assign S_AXI_RRESP	= axi_rresp;
assign S_AXI_RVALID	= axi_rvalid;

always @( posedge S_AXI_ACLK )
begin
  if ( S_AXI_ARESETN == 1'b0 )
    begin
      axi_awready <= 1'b0;
    end 
  else
    begin    
      if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)
        begin
          axi_awready <= 1'b1;
        end
      else           
        begin
          axi_awready <= 1'b0;
        end
    end 
end       

always @( posedge S_AXI_ACLK )
begin
  if ( S_AXI_ARESETN == 1'b0 )
    begin
      axi_awaddr <= 0;
    end 
  else
    begin    
      if (~axi_awready && S_AXI_AWVALID && S_AXI_WVALID)
        begin
          axi_awaddr <= S_AXI_AWADDR;
        end
    end 
end       

always @( posedge S_AXI_ACLK )
begin
  if ( S_AXI_ARESETN == 1'b0 )
    begin
      axi_wready <= 1'b0;
    end 
  else
    begin    
      if (~axi_wready && S_AXI_WVALID && S_AXI_AWVALID)
        begin
          axi_wready <= 1'b1;
        end
      else
        begin
          axi_wready <= 1'b0;
        end
    end 
end       

assign slv_reg_wren = axi_wready && S_AXI_WVALID && axi_awready && S_AXI_AWVALID;

always @( posedge S_AXI_ACLK )
begin
  if ( S_AXI_ARESETN == 1'b0 )
    begin
      axi_bvalid  <= 0;
      axi_bresp   <= 2'b0;
    end 
  else
    begin    
      if (axi_awready && S_AXI_AWVALID && ~axi_bvalid && axi_wready && S_AXI_WVALID)
        begin
          axi_bvalid <= 1'b1;
          axi_bresp  <= 2'b0;  
        end                   
      else
        begin
          if (S_AXI_BREADY && axi_bvalid) 
            begin
              axi_bvalid <= 1'b0; 
            end  
        end
    end
end   

always @( posedge S_AXI_ACLK )
begin
  if ( S_AXI_ARESETN == 1'b0 )
    begin
      axi_arready <= 1'b0;
      axi_araddr  <= 32'b0;
    end 
  else
    begin    
      if (~axi_arready && S_AXI_ARVALID)
        begin
          axi_arready <= 1'b1;
          axi_araddr  <= S_AXI_ARADDR;
        end
      else
        begin
          axi_arready <= 1'b0;
        end
    end 
end       

always @( posedge S_AXI_ACLK )
begin
  if ( S_AXI_ARESETN == 1'b0 )
    begin
      axi_rvalid <= 0;
      axi_rresp  <= 0;
    end 
  else
    begin    
      if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)
        begin
          axi_rvalid <= 1'b1;
          axi_rresp  <= 2'b0;
        end   
      else if (axi_rvalid && S_AXI_RREADY)
        begin
          axi_rvalid <= 1'b0;
        end                
    end
end    

always @( posedge S_AXI_ACLK )
begin
  if ( S_AXI_ARESETN == 1'b0 )
    begin
      axi_rdata  <= 0;
    end 
  else
    begin    
      if (slv_reg_rden)
        begin
          axi_rdata <= reg_data_out; 
        end   
    end
end    

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg0;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg0 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d0) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg0[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg1;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg1 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d1) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg1[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg2;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg2 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d2) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg2[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg3;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg3 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d3) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg3[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg4;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg4 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d4) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg4[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg5;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg5 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d5) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg5[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg6;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg6 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d6) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg6[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg7;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg7 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d7) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg7[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg8;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg8 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d8) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg8[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg9;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg9 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d9) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg9[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg10;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg10 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d10) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg10[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg11;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg11 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d11) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg11[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg12;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg12 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d12) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg12[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg13;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg13 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d13) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg13[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg14;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg14 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d14) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg14[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

reg [C_S_AXI_DATA_WIDTH-1:0]slv_reg15;
always @( posedge S_AXI_ACLK )
if ( S_AXI_ARESETN == 1'b0 )
	begin
		slv_reg15 <= 0;
	end
else
	if(slv_reg_wren & (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB]=='d15) )
		for ( byte_index = 0; byte_index <= (C_S_AXI_DATA_WIDTH/8)-1; byte_index = byte_index+1 )
			if ( S_AXI_WSTRB[byte_index] == 1 ) 
				begin
					slv_reg15[(byte_index*8) +: 8] <= S_AXI_WDATA[(byte_index*8) +: 8];
				end

assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;
always @(*)
begin
	case ( axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB] )
		'd0:reg_data_out<=slv_reg0;
		'd1:reg_data_out<=slv_reg1;
		'd2:reg_data_out<=slv_reg2;
		'd3:reg_data_out<=slv_reg3;
		'd4:reg_data_out<=slv_reg4;
		'd5:reg_data_out<=slv_reg5;
		'd6:reg_data_out<=slv_reg6;
		'd7:reg_data_out<=slv_reg7;
		'd8:reg_data_out<=slv_reg8;
		'd9:reg_data_out<=slv_reg9;
		'd10:reg_data_out<=slv_reg10;
		'd11:reg_data_out<=slv_reg11;
		'd12:reg_data_out<=slv_reg12;
		'd13:reg_data_out<=slv_reg13;
		'd14:reg_data_out<=slv_reg14;
		'd15:reg_data_out<=slv_reg15;
        default : reg_data_out <= 0;
	endcase
end

endmodule
```



:two: 基于AXI4-Lite总线的master文件AXI_GP_M_BFM.sv

```verilog
`timescale 1ns / 1ps
module AXI_GP_M_BFM #
(
    parameter C_M_AXI_DATA_WIDTH=32,
    parameter C_M_AXI_ADDR_WIDTH=6 
)
(
    input M_AXI_ACLK,
    input M_AXI_ARESETN,
    
    //AR channel
    output reg M_AXI_ARVALID,
    input M_AXI_ARREADY,
    output reg [C_M_AXI_ADDR_WIDTH-1:0]M_AXI_ARADDR,
    output [2:0]M_AXI_ARPROT,//=3'b0

    //Rd channel
    input [C_M_AXI_DATA_WIDTH-1:0]M_AXI_RDATA,
    input [1:0]M_AXI_RRESP,//ignore
    input M_AXI_RVALID,
    output reg M_AXI_RREADY,

    //AW channel
    output reg M_AXI_AWVALID,
    input M_AXI_AWREADY,
    output reg [C_M_AXI_ADDR_WIDTH-1:0]M_AXI_AWADDR,
    output [2:0]M_AXI_AWPROT,//=3'h0

    //Wr channel
    output reg [C_M_AXI_DATA_WIDTH-1:0]M_AXI_WDATA,
    output reg M_AXI_WVALID,
    input M_AXI_WREADY,
    output [C_M_AXI_DATA_WIDTH/8-1:0]M_AXI_WSTRB,//={(C_M_AXI_DATA_WIDTH/8){1'b1}}        

    //Wr Resp
    input [1:0]M_AXI_BRESP,//ignore
    input M_AXI_BVALID,
    output reg M_AXI_BREADY
);

assign M_AXI_AWPROT=3'h0;
assign M_AXI_WSTRB={(C_M_AXI_DATA_WIDTH/8){1'b1}};
assign M_AXI_ARPROT=3'b0;

always @(negedge M_AXI_ARESETN)
begin
    M_AXI_AWVALID<=0;
    M_AXI_AWADDR<=0;
    M_AXI_WDATA<=0;
    M_AXI_WVALID<=0;
    M_AXI_ARVALID<=0;
    M_AXI_ARADDR<=0;
    M_AXI_RREADY<=0;
end

always @(posedge M_AXI_ACLK or negedge M_AXI_ARESETN)                                                                                                     
if(~M_AXI_ARESETN)                                                           
    M_AXI_BREADY<=1'b0;                                                                                                                          
else
    if(M_AXI_BVALID & ~M_AXI_BREADY)                                                                               
        M_AXI_BREADY<=1'b1;                                                                                                                                       
    else
        if(M_AXI_BVALID & M_AXI_BREADY)
            M_AXI_BREADY<=1'b0;

task write(input int unsigned addr,data);
begin
    @(posedge M_AXI_ACLK) M_AXI_AWVALID<=1;M_AXI_AWADDR<=addr;M_AXI_WVALID<=1;M_AXI_WDATA<=data;
    @(posedge M_AXI_ACLK);
    while((M_AXI_WVALID|M_AXI_AWVALID)==1)
        begin
            if(M_AXI_AWREADY)
                M_AXI_AWVALID<=0;
            if(M_AXI_WREADY)
                M_AXI_WVALID<=0;
            @(posedge M_AXI_ACLK);
        end
    while(~(M_AXI_BVALID && M_AXI_BREADY)) @(posedge M_AXI_ACLK);
end
endtask

task read(input int unsigned addr,output int unsigned data);
begin
    M_AXI_ARADDR<=addr;
    @(posedge M_AXI_ACLK) M_AXI_ARVALID<=1;
    @(posedge M_AXI_ACLK);
    while(~(M_AXI_ARVALID && M_AXI_ARREADY)) @(posedge M_AXI_ACLK);
    M_AXI_ARVALID<=0;
    @(posedge M_AXI_ACLK);
    while(~M_AXI_RVALID) @(posedge M_AXI_ACLK);
    M_AXI_RREADY<=1;
    @(posedge M_AXI_ACLK) M_AXI_RREADY<=0;
    data=M_AXI_RDATA;
end
endtask
endmodule
```

:three: 仿真用的testbench文件testbench.sv（这两个.sv文件是用system verilog编写）

（**注**：系统共有master和slave两个模块，所以在testbench中实例化这两个模块，即调用两个模块。

   在initial中，先给master的写地址和写数据信号赋值，观察master和slave通信的仿真波形。再给master的读地址信号和读数据信号赋值，观察master和slave通信的仿真波形。）

```verilog
`timescale 1ns / 1ps

module testbench;

bit M_AXI_ACLK; //bit数据类型，其只有0或者1两个值，没有X等值
always #5 M_AXI_ACLK=~M_AXI_ACLK;
bit M_AXI_ARESETN;
   parameter C_M_AXI_DATA_WIDTH=32;
   parameter C_M_AXI_ADDR_WIDTH=6;
//将master的端口添加进来，并将input和output都改成wire
//AR channel
wire M_AXI_ARVALID;
wire M_AXI_ARREADY;
wire [C_M_AXI_ADDR_WIDTH-1:0]M_AXI_ARADDR;
wire [2:0]M_AXI_ARPROT;//=3'b0
//Rd channel
wire [C_M_AXI_DATA_WIDTH-1:0]M_AXI_RDATA;
wire [1:0]M_AXI_RRESP;//ignore
wire M_AXI_RVALID;
wire M_AXI_RREADY;
//AW channel
wire M_AXI_AWVALID;
wire M_AXI_AWREADY;
wire [C_M_AXI_ADDR_WIDTH-1:0]M_AXI_AWADDR;
wire [2:0]M_AXI_AWPROT;//=3'h0
//Wr channel
wire [C_M_AXI_DATA_WIDTH-1:0]M_AXI_WDATA;
wire M_AXI_WVALID;
wire M_AXI_WREADY;
wire [C_M_AXI_DATA_WIDTH/8-1:0]M_AXI_WSTRB;//={(C_M_AXI_DATA_WIDTH/8){1'b1}}        
//Wr Resp
wire [1:0]M_AXI_BRESP;//ignore
wire M_AXI_BVALID;
wire M_AXI_BREADY;

int unsigned rdata;
initial
begin
M_AXI_ARESETN=1;
#30 M_AXI_ARESETN=0;
#30 M_AXI_ARESETN=1;//仿真之前的复位过程
repeat(30) @(posedge M_AXI_ACLK);
    u_AXI_GP_M_BFM.write(16,20); //调用AXI_GP_M_BFM里的write函数，发出给地址16写入数据20的信号
    u_AXI_GP_M_BFM.read(16,rdata);  //调用AXI_GP_M_BFM里的read函数,将地址16的数据读出来，保存到rdata
#100 $stop;
end

dut_axi_lite_slave u_dut_axi_lite_slave //例化待测试slave模块
(
M_AXI_ACLK,
M_AXI_ARESETN,
M_AXI_AWADDR,
 M_AXI_AWPROT,
M_AXI_AWVALID,
 M_AXI_AWREADY,
M_AXI_WDATA,
 M_AXI_WSTRB,
  M_AXI_WVALID,
 M_AXI_WREADY,
M_AXI_BRESP,
M_AXI_BVALID,
M_AXI_BREADY,
M_AXI_ARADDR,
M_AXI_ARPROT,
M_AXI_ARVALID,
M_AXI_ARREADY,
M_AXI_RDATA,
M_AXI_RRESP,
M_AXI_RVALID,
M_AXI_RREADY
);

AXI_GP_M_BFM u_AXI_GP_M_BFM //例化待测试master模块
(
M_AXI_ACLK,
M_AXI_ARESETN,
    //AR channel
M_AXI_ARVALID,
M_AXI_ARREADY,
M_AXI_ARADDR,
M_AXI_ARPROT,//=3'b0
    //Rd channel
M_AXI_RDATA,
M_AXI_RRESP,//ignore
 M_AXI_RVALID,
M_AXI_RREADY,
    //AW channel
M_AXI_AWVALID,
M_AXI_AWREADY,
M_AXI_AWADDR,
M_AXI_AWPROT,//=3'h0
    //Wr channel
M_AXI_WDATA,
M_AXI_WVALID,
M_AXI_WREADY,
M_AXI_WSTRB,//={(C_M_AXI_DATA_WIDTH/8){1'b1}}        
    //Wr Resp
M_AXI_BRESP,//ignore
M_AXI_BVALID,
M_AXI_BREADY
);

endmodule
```

将三个文件添加完毕后，点击Run Simulation，然后点击![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E4%BB%BF%E7%9C%9F2.png) 

**（左侧按键用来将所有仿真波形复位，中间按键是开始仿真，一般运行到$stop设置的时间，右边按键可以定时运行） **

通过下图所示位置，可以选择查看相应模块的仿真波形。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E4%BB%BF%E7%9C%9F3.png)

仿真波形如下：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi-lite%E4%BB%BF%E7%9C%9F4.png)



#### （3）上板观察AXI4-Lite总线信号（内含IP的封装和调用，ila的使用）

##### 实例一：基于AXI4-Lite总线slave的简单读写

**（工程名称为axi_lite_test1）**



###### 1、在zybo开发板上运行

**一、封装自定义IP**  

**先将AXI_LITE_SLAVE.v文件封装成一个IP，具体步骤为：**

- 首先添加**AXI_LITE_SLAVE.v** 文件到Design Source

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E5%B0%81%E8%A3%85IP_1.png)

- 点击Tools$\to$ Create and Packsge New IP$\to$ Next$\to$ Package your current project$\to$ Next

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E5%B0%81%E8%A3%85IP_2.png)

- 选择存储IP的目录，并且勾选Include IP generated files

![1551690602528](/C:/Users/fpga/AppData/Roaming/Typora/typora-user-images/1551690602528.png)

- 选择Next$\to$ Finish

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E5%B0%81%E8%A3%85IP_3.png)

- 选择Customization GUI，预览即将打包的IP

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E5%B0%81%E8%A3%85IP_4.png)

- 选择Review and Package，然后点击Package IP

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E5%B0%81%E8%A3%85IP_5.png)

此时已经成功封装了一个基于AXI-Lite总线的Slave IP。

**二、通过自定义IP建立工程**。

 有两种方式，一种是用一个基于AXI-Lite总线的主机master IP，另一种是直接用Zynq芯片对Slave从机进行读取（AXI协议是xilinx和ARM公司同时开发，所以可以直接将从机挂到ARM上）。这里，采用第二种方法。

**SOC硬件部分：** 

- 创建新的工程，先将自定义的IP添加到IP目录：（Vivado 2016.4）

​       选择Project Settings，点击IP，点击+，添加IP路径

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E6%B7%BB%E5%8A%A0IP%E8%B7%AF%E5%BE%84.png)

- 选择Create Block Design，添加zynq IP，点击Run Connection Automation，再添加自定义的IP，点击Run Connection Automation

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/AXI_LITE%20block%20design.png)

- 保存，然后点击Validata Design，验证工程的正确性

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/AXI_LITE%20block%E9%AA%8C%E8%AF%81.png)

- 进入Address Editor，查看从机slave的第一个寄存器的基地址为0x43C0_0000

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/axi_lite3.png)

- 加入片内逻辑分析仪ila IP，将SLOT_0_AXI连接到slave从机的S_AXI,将clk连接到zynq IP的FCLK_CLK0，保存

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/AXI_lite%20block%20ila.png)

- 在Block Design文件上右键，选择Create HDL Wrapper，勾选Let Vivado manage wrapper and auto-updata,点击ok
- 再一次在Block Design文件上右键，选择Generate Output Products，勾选Global，点击Generate
- 依次执行综合、实现和生成比特流
- 导出SOC硬件到SDK

**SDK软件部分：** 

- 建立hello world模板工程，在hello world.c的基础上进行修改

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"

//由上述讲解可知，此slave从机的基地址是0x43C00000，即第一个寄存器的地址为0x43C00000，第二个寄存器的地址为0x43C00004
#define axi_lite_slave1 (unsigned int *) 0x43C00000//定义一个地址指针，并将其命名为axi_lite_slave1
#define axi_lite_slave2 (unsigned int *) 0x43C00004//定义一个地址指针，并将其命名为axi_lite_slave2

int main()
{
    init_platform();
    print("Hello World\n\r");
    while(1)//这里循环的目的是，让CPU持续工作，以便可以用ila抓取AXI-Lite总线的波形
    {
    * axi_lite_slave1 =10 ;//通过指针给地址0x43C00000赋值10
    xil_printf("reg0=%d\r\n",*axi_lite_slave1);

    * axi_lite_slave2 =100 ;//通过指针给地址0x43C00004赋值100
    xil_printf("reg1=%d\r\n",*axi_lite_slave2);
    }
    cleanup_platform();
    return 0;
}
```

另一种写法：

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
int main()
{
    init_platform();
    print("Hello World\n\r");
    while(1)
    {
        *(unsigned int *) 0x43C00000 =10;
        xil_printf("reg0=%d\r\n, *(unsigned int *) 0x43C00000);
 	    *(unsigned int *) 0x43C00004 =100;
        xil_printf("reg1=%d\r\n, *(unsigned int *) 0x43C00004);
    }
 	cleanup_platform();
    return 0;
}
```



**三、利用ila查看波形：**

- 在vivado界面中，选择Hardware Manager$\to$ Open Target$\to$ Auto Connect，成功后出现如下界面。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/ila1.png)

- 因为时钟太快，为了能够抓取到波形，在Trigger Setup中设置触发条件，只有当ARVALID==1时，才进行抓取。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/ila4.png)

- 设置完触发条件之后，在Waveform中点击![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/ila5.png) ，开始抓取波形。（为了观察方便，需要提前移动信号的位置，把写请求通道和写数据通道的信号移动到前面，并设置成不同的颜色）

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/ila6.png)

**如图所示，在写请求通道中，valid和ready信号同时为1，写请求有效，此时的写地址为0x43C00000。在下一个周期，写数据通道中，当valid个ready同时有效时，向地址0x43C00000写入数据10。**由此验证了AXI-Lite总线协议。



###### 2、在PYNQ开发板上运行

（加速器课程第五节）



##### 实例二：基于AXI4-Lite总线的GPIO IP

（加速器课程第六节）



##### 实例三：RS485协议与基于FIFO收发的数据通路设计

（加速器课程第七节）



### 6、基于AXI4( full )总线的DMA模块设计

#### （1）DMA工作原理

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DMA%E6%84%8F%E4%B9%891.png)

如图，在这种架构中，CPU控制DDR、ADC、UART和DMA四个模块。

现在要将ADC采集的数据通过串口输出，

- 如果不使用DMA，则实现的一般方式为：

while( 1 )

{

data=read_REG( ADC ) //从ADC寄存器读取数据

write_REG（ data ）//将数据写到串口的寄存器

}

这样的话，CPU要一直工作，进行数据的搬移。

- 当使用DMA时

实现方式是CPU先配置DMA，然后由DMA进行数据的搬移，这样就可以解放CPU。

如图，DMA一方面受CPU控制，另一方面，可以作为主机，访问其他模块。但是这种架构存在风险，DMA可能会访问自身，造成错误。所以可以采用下图这种架构，DMA只访问DDR。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DMA%E6%84%8F%E4%B9%892.png)



#### （2）DMA环路设计

**DMA需要实现的功能：** 

首先应该有start和done等控制信号。

对于读：可以从DDR中自定义的基地址读数据，每次搬运数据的长度为1-65536（64k）Byte，可以将读来的数据输出（如FIFO）

对于写：可以将（FIFO）输入的数据写到DDR的任意地址，每次搬运数据的长度为1-65536（64k）Byte

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DMA%E8%A6%81%E6%B1%82.png)

首先DMA应该有AXI4-Lite接口，以实现CPU通过配置DMA的寄存器来控制DMA工作。

**本次工程要实现的数据通路是：DMA先从DDR的一个地址读出数据，再写回DDR内另一个地址。** 

所以DMA需要有4个寄存器，分别为：

REG[0] : start/done , REG[1] : 读操作基地址，REG[2] : 写操作基地址，REG[3]：读写长度LEN



要求DMA一次搬运数据大小为65536（64k）Byte，而对于32位（4 Byte）总线，进行burst传输，每条命令最多传输的数据大小为：4 Byte x 256 cycle = 1k Byte，所以要连续进行64个命令读写。

假设第一条读地址命令的地址为0x10000，如下图：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DMA1.png)

这就是同时应用了AXI4总线的outstanding模式和burst模式，每次读命令，都会读256个周期的数据（一个周期读一个数），连续发出64个读命令，则最终可以读64k Byte的数据。



在此工程中，数据流向如下图，先从DDR读出数据，再写回DDR。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DMA2.png)

**功能仿真（dma_loop）：**

首先新建工程，工程名为dma_loop，然后添加文件dma.v、dma_reg.v、send_rd_cmd.v和send_wr_cmd.v。

```
代码讲解：





```

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DMA5.png)

RTL图：

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DMA_loop.png)



dma.v

```verilog
`timescale 1ns / 1ps

module dma #
(
    parameter C_AXI_DATA_WIDTH=32,
    parameter C_M_AXI_ID_WIDTH=4
)
(
    input clk,
    input rst_n,
    
    //AR channel
    input S_AXI_ARVALID,
    output S_AXI_ARREADY,
    input [4-1:0]S_AXI_ARADDR,
    input [2:0]S_AXI_ARPROT,
    
    //Rd channel
    output [32-1:0]S_AXI_RDATA,
    output [1:0]S_AXI_RRESP,
    output S_AXI_RVALID,
    input S_AXI_RREADY,
    
    //AW channel
    input S_AXI_AWVALID,
    output S_AXI_AWREADY,
    input [4-1:0]S_AXI_AWADDR,
    input [2:0]S_AXI_AWPROT,
    
    //Wr channel
    input [32-1:0]S_AXI_WDATA,
    input S_AXI_WVALID,
    output S_AXI_WREADY,
    input [4-1:0]S_AXI_WSTRB,   
    
    //Wr Resp
    output [1:0]S_AXI_BRESP,
    output S_AXI_BVALID,
    input S_AXI_BREADY,
    
    //AR channel
    output [C_M_AXI_ID_WIDTH-1 : 0] M_AXI_ARID,
    output [32-1 : 0] M_AXI_ARADDR,
    output [7 : 0] M_AXI_ARLEN,
    output [2 : 0] M_AXI_ARSIZE,//=clogb2((`AXI_DATA_WIDTH/8)-1);
    output [1 : 0] M_AXI_ARBURST,//=2'b01;
    output  M_AXI_ARLOCK,//=1'b0;
    output [3 : 0] M_AXI_ARCACHE,//=4'b0010;
    output [2 : 0] M_AXI_ARPROT,//=3'h0;
    output [3 : 0] M_AXI_ARQOS,//=4'h0;
    output  M_AXI_ARVALID,
    input  M_AXI_ARREADY,
    
    //Rd channel
    input [C_M_AXI_ID_WIDTH-1 : 0] M_AXI_RID,
    input [C_AXI_DATA_WIDTH-1 : 0] M_AXI_RDATA,
    input [1 : 0] M_AXI_RRESP,//ignore
    input  M_AXI_RLAST,
    input  M_AXI_RVALID,
    output  M_AXI_RREADY,
    
    //AW channel
    output [C_M_AXI_ID_WIDTH-1 : 0] M_AXI_AWID,
    output [32-1 : 0] M_AXI_AWADDR,
    output [7    : 0] M_AXI_AWLEN,
    output [2 : 0] M_AXI_AWSIZE,//=clogb2((`AXI_DATA_WIDTH/8)-1);
    output [1 : 0] M_AXI_AWBURST,//=2'b01;
    output  M_AXI_AWLOCK,//1'b0;
    output [3 : 0] M_AXI_AWCACHE,//=4'b0010
    output [2 : 0] M_AXI_AWPROT,//=3'h0;
    output [3 : 0] M_AXI_AWQOS,//=4'h0;
    output  M_AXI_AWVALID,
    input  M_AXI_AWREADY,
    
    //Wr channel
    output [C_AXI_DATA_WIDTH-1 : 0] M_AXI_WDATA,
    output [C_AXI_DATA_WIDTH/8-1 : 0] M_AXI_WSTRB,
    output  M_AXI_WLAST,
    output  M_AXI_WVALID,
    input  M_AXI_WREADY,
    
    //Resp channel
    input [C_M_AXI_ID_WIDTH-1 : 0] M_AXI_BID,//ignore
    input [1 : 0] M_AXI_BRESP,//ignore
    input  M_AXI_BVALID,//Bvalid and Bread means a a write response.
    output  M_AXI_BREADY//Bvalid and Bread means a a write response.
);

function integer clogb2 (input integer bit_depth);              
begin                                                           
for(clogb2=0; bit_depth>0; clogb2=clogb2+1)                   
  bit_depth = bit_depth >> 1;                                 
end                                                           
endfunction

assign M_AXI_AWSIZE=clogb2((C_AXI_DATA_WIDTH/8)-1);
assign M_AXI_AWBURST=2'b01;
assign M_AXI_AWLOCK=1'b0;
assign M_AXI_AWCACHE=4'b0010;
assign M_AXI_AWPROT=3'h0;
assign M_AXI_AWQOS=4'h0;

assign M_AXI_ARSIZE=clogb2((C_AXI_DATA_WIDTH/8)-1);
assign M_AXI_ARBURST=2'b01; 
assign M_AXI_ARLOCK=1'b0;
assign M_AXI_ARCACHE=4'b0010;
assign M_AXI_ARPROT=3'h0;
assign M_AXI_ARQOS=4'h0;

assign M_AXI_ARID=0;
assign M_AXI_AWID=0;
assign M_AXI_BREADY=1'b1;

wire start,done;
wire [31:0]src_addr;
wire [31:0]dst_addr;
wire [15:0]size;

assign M_AXI_WDATA=M_AXI_RDATA;
assign M_AXI_WSTRB={(C_AXI_DATA_WIDTH/8){1'b1}};
assign M_AXI_WLAST=M_AXI_RLAST;
assign M_AXI_WVALID=M_AXI_RVALID;
assign M_AXI_RREADY=M_AXI_WREADY;

dma_reg u_dma_reg
(
    .clk(clk),
    .rst_n(rst_n),
    
    //AR channel
    .S_AXI_ARVALID(S_AXI_ARVALID),
    .S_AXI_ARREADY(S_AXI_ARREADY),
    .S_AXI_ARADDR(S_AXI_ARADDR),
    .S_AXI_ARPROT(S_AXI_ARPROT),
    
    //Rd channel
    .S_AXI_RDATA(S_AXI_RDATA),
    .S_AXI_RRESP(S_AXI_RRESP),
    .S_AXI_RVALID(S_AXI_RVALID),
    .S_AXI_RREADY(S_AXI_RREADY),
    
    //AW channel
    .S_AXI_AWVALID(S_AXI_AWVALID),
    .S_AXI_AWREADY(S_AXI_AWREADY),
    .S_AXI_AWADDR(S_AXI_AWADDR),
    .S_AXI_AWPROT(S_AXI_AWPROT),
    
    //Wr channel
    .S_AXI_WDATA(S_AXI_WDATA),
    .S_AXI_WVALID(S_AXI_WVALID),
    .S_AXI_WREADY(S_AXI_WREADY),
    .S_AXI_WSTRB(S_AXI_WSTRB),   
    
    //Wr Resp
    .S_AXI_BRESP(S_AXI_BRESP),
    .S_AXI_BVALID(S_AXI_BVALID),
    .S_AXI_BREADY(S_AXI_BREADY),
    
    .start(start),
    .done(done),
    
    .src_addr(src_addr),
    .dst_addr(dst_addr),
    .size(size)
);

send_rd_cmd #
(
    .C_AXI_DATA_WIDTH(C_AXI_DATA_WIDTH)
)u_send_rd_cmd
(
    .clk(clk),
    .rst_n(rst_n),
    
    .start(start),
    .src_addr(src_addr),
    .size(size),//real_size - 1
    
    //AR channel
    .M_AXI_ARADDR(M_AXI_ARADDR),
    .M_AXI_ARLEN(M_AXI_ARLEN),
    .M_AXI_ARVALID(M_AXI_ARVALID),
    .M_AXI_ARREADY(M_AXI_ARREADY)
);

send_wr_cmd #
(
    .C_AXI_DATA_WIDTH(32)
)u_send_wr_cmd
(
    .clk(clk),
    .rst_n(rst_n),
    
    .start(start),
    .dst_addr(dst_addr),
    .size(size),//real_size - 1
    
    //AR channel
    .M_AXI_AWADDR(M_AXI_AWADDR),
    .M_AXI_AWLEN(M_AXI_AWLEN),
    .M_AXI_AWVALID(M_AXI_AWVALID),
    .M_AXI_AWREADY(M_AXI_AWREADY)
);

reg [15:0]cnt;
always @(posedge clk or negedge rst_n)
if(~rst_n)
    cnt<=0;
else
    if(start)
        cnt<=0;
    else
        if(M_AXI_WVALID&M_AXI_WREADY)
            cnt<=cnt+1;

assign done=(M_AXI_WVALID&M_AXI_WREADY)&(cnt==size);
    
endmodule

```

dma_reg.v

```verilog
`timescale 1ns / 1ps

module dma_reg
(
    input clk,
    input rst_n,
 
     //AR channel
    input S_AXI_ARVALID,
    output S_AXI_ARREADY,
    input [4-1:0]S_AXI_ARADDR,
    input [2:0]S_AXI_ARPROT,

    //Rd channel
    output [32-1:0]S_AXI_RDATA,
    output [1:0]S_AXI_RRESP,
    output S_AXI_RVALID,
    input S_AXI_RREADY,

    //AW channel
    input S_AXI_AWVALID,
    output S_AXI_AWREADY,
    input [4-1:0]S_AXI_AWADDR,
    input [2:0]S_AXI_AWPROT,

    //Wr channel
    input [32-1:0]S_AXI_WDATA,
    input S_AXI_WVALID,
    output S_AXI_WREADY,
    input [4-1:0]S_AXI_WSTRB,   

    //Wr Resp
    output [1:0]S_AXI_BRESP,
    output S_AXI_BVALID,
    input S_AXI_BREADY,
    
    output start,//reg0
    input done,//reg0
    
    output reg [31:0]src_addr,//reg1
    output reg [31:0]dst_addr,//reg2
    output reg [15:0]size//reg3
);

reg done_r;

assign S_AXI_BRESP=2'b0;
reg axi_bvalid;
assign S_AXI_BVALID=axi_bvalid;
always @(posedge clk or negedge rst_n)
if(~rst_n)
    axi_bvalid<=1'b0;
else
    if(S_AXI_WVALID&S_AXI_WREADY)
        axi_bvalid<=1'b1;
    else
        if(S_AXI_BREADY)
            axi_bvalid<=1'b0;

reg [1:0]addr_word_w;
wire [1:0]addr_word_w_comb;
always @(posedge clk or negedge rst_n)
if(~rst_n)
    addr_word_w<=0;
else
    if(S_AXI_AWVALID&S_AXI_AWREADY)
        addr_word_w<=S_AXI_AWADDR[3:2];
        
assign addr_word_w_comb=(S_AXI_AWVALID&S_AXI_AWREADY)?S_AXI_AWADDR[3:2]:addr_word_w;
assign S_AXI_AWREADY=1'b1;//S_AXI_AWVALID&S_AXI_WVALID;

reg w_phase;
always @(posedge clk or negedge rst_n)
if(~rst_n)
    w_phase=1'b0;
else
    if(S_AXI_AWVALID&S_AXI_AWREADY)
        w_phase<=1;
    else
        if(S_AXI_WVALID&S_AXI_WREADY)
            w_phase<=0;

assign S_AXI_WREADY=w_phase;
always @(posedge clk or negedge rst_n)
if(~rst_n)
begin
    src_addr<=0;
    dst_addr<=0;
    size<=0;
end
else
    if(S_AXI_WVALID&S_AXI_WREADY)
    case(addr_word_w_comb)
        2'd1:begin src_addr<=S_AXI_WDATA;end
        2'd2:begin dst_addr<=S_AXI_WDATA;end
        2'd3:begin size<=S_AXI_WDATA[15:0];end
    endcase
    
assign S_AXI_ARREADY=1'b1;

assign S_AXI_RRESP=2'b0;
reg [32-1:0]rdata;
assign S_AXI_RDATA=rdata;
reg rvalid;
assign S_AXI_RVALID=rvalid;
            
always @(posedge clk or negedge rst_n)
if(~rst_n)
    begin rvalid<=1'b0;rdata<=32'b0;end
else
    if(S_AXI_ARVALID&S_AXI_ARREADY)
    begin
        rvalid<=1'b1;
        case(S_AXI_ARADDR[3:2])
            2'd0:rdata<={30'b0,done_r,1'b0};
            2'd1:rdata<=src_addr;
            2'd2:rdata<=dst_addr;
            2'd3:rdata<={16'b0,size};
        endcase
    end
    else
        if(S_AXI_RVALID&S_AXI_RREADY)
            rvalid<=1'b0;
            
assign start=S_AXI_WVALID&S_AXI_WREADY&(addr_word_w_comb==0)&S_AXI_WDATA[0];
            
always @(posedge clk or negedge rst_n)
if(~rst_n)
    done_r<=0;
else
    if(start)
        done_r<=0;
    else
        if(done)
            done_r<=1;
            
endmodule

```

send_rd_cmd.v

```verilog
`timescale 1ns / 1ps

module send_rd_cmd #
(
    parameter C_AXI_DATA_WIDTH=32
)
(
    input clk,
    input rst_n,
    
    input start,
    input [31:0]src_addr,
    input [15:0]size,//real_size - 1
    
    //AR channel
    output [32-1 : 0] M_AXI_ARADDR,
    output [7 : 0] M_AXI_ARLEN,
    output  M_AXI_ARVALID,
    input  M_AXI_ARREADY
);

reg state;
reg [15:0]ptr;
reg arvalid;
reg [31:0]raddr;

wire last_burst=(ptr[15:8]==size[15:8]);
assign M_AXI_ARLEN=last_burst?size[7:0]:8'hff;

assign M_AXI_ARVALID=arvalid;
assign M_AXI_ARADDR=raddr;

always @(posedge clk or negedge rst_n)
if(~rst_n)
begin
    ptr<=0;
    state<=0;
    arvalid<=0;
    raddr<=0;
end
else
    case(state)
        0:
            if(start)
            begin
                state<=1;
                arvalid<=1;
                raddr<=src_addr;
            end
        1:
            if(M_AXI_ARVALID&M_AXI_ARREADY)
            begin
                if(last_burst)
                begin
                    arvalid<=0;
                    raddr<=0;
                    ptr<=0;
                    state<=0;
                end
                else
                begin
                    raddr<=raddr+(C_AXI_DATA_WIDTH/8)*256;
                    ptr<=ptr+256;
                end
            end
    endcase

endmodule

```

send_wr_cmd.v

```verilog
`timescale 1ns / 1ps

module send_wr_cmd #
(
    parameter C_AXI_DATA_WIDTH=32
)
(
    input clk,
    input rst_n,
    
    input start,
    input [31:0]dst_addr,
    input [15:0]size,//real_size - 1
    
    //AR channel
    output [32-1 : 0] M_AXI_AWADDR,
    output [7    : 0] M_AXI_AWLEN,
    output  M_AXI_AWVALID,
    input  M_AXI_AWREADY
);

reg state;
reg [15:0]ptr;
reg awvalid;
reg [31:0]waddr;

wire last_burst=(ptr[15:8]==size[15:8]);
assign M_AXI_AWLEN=last_burst?size[7:0]:8'hff;

assign M_AXI_AWVALID=awvalid;
assign M_AXI_AWADDR=waddr;

always @(posedge clk or negedge rst_n)
if(~rst_n)
begin
    ptr<=0;
    state<=0;
    awvalid<=0;
    waddr<=0;
end
else
    case(state)
        0:
            if(start)
            begin
                state<=1;
                awvalid<=1;
                waddr<=dst_addr;
            end
        1:
            if(M_AXI_AWVALID&M_AXI_AWREADY)
            begin
                if(last_burst)
                begin
                    awvalid<=0;
                    waddr<=0;
                    ptr<=0;
                    state<=0;
                end
                else
                begin
                    waddr<=waddr+(C_AXI_DATA_WIDTH/8)*256;
                    ptr<=ptr+256;
                end
            end
    endcase

endmodule

```



在仿真文件中添加文件：

**AXI_HP_Slave.sv** ，作为DMA模块访问的从设备，相当于DDR

**AXI_GP_M_BFM.sv** ， 负责对DMA模块的寄存器进行配置

**testbench.sv**，仿真文件

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DMA%E4%BB%BF%E7%9C%9F.png)



**基于AXI4总线DMA的环路设计（dma_loop2）：** 

首先将DMA模块进行封装成 IP，然后搭建Block Design。

添加zynq IP，对其进行配置，选择AXI-HP接口

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DMA3.png)

接下来点击自动连接即可，然后点击Validata Design，验证工程的正确性。

添加 ila IP，抓取波形。

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/DMA4.png)

经过综合、实现和生成比特流文件之后，导入到SDK中，然后再SDK中建立新的工程，添加代码：

```c
#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "sleep.h"
#include "xil_cache.h"

int A[4096];//用DMA将数组A搬运到数组B
int B[4096];

//#define EN_CACHE
//当屏蔽此定义时，不会使用cache
/*
关于cache
DMA工作时是直接访问DDR里的数据，但是CPU访问DDR时，中间还要隔着一层cache，
这样的话，有可能DMA真正要读的数据，还停留在cache里，DMA读到的是旧的数据

*/

int main()
{
    init_platform();

	#ifndef EN_CACHE
    	Xil_DCacheDisable();
	#endif

    print("Hello World\r\n");

    for(int i=0;i<4096;i++)
    	A[i]=i;

	#ifdef EN_CACHE
    Xil_DCacheFlushRange((unsigned int)A,4096*sizeof(int));
	#endif

	*(unsigned int *)(XPAR_DMA_0_BASEADDR+4)=(unsigned int)A;//reg0 raddr
	*(unsigned int *)(XPAR_DMA_0_BASEADDR+8)=(unsigned int)B;//reg1 waddr
	*(unsigned int *)(XPAR_DMA_0_BASEADDR+12)=4095;//reg3 len

	*(unsigned int *)(XPAR_DMA_0_BASEADDR)=1;//reg0 start

	while(*(unsigned int *)(XPAR_DMA_0_BASEADDR)==0) {usleep(10);}//reg0 done，循环执行，判断是否传输结束

	#ifdef EN_CACHE
	Xil_DCacheInvalidate();
	#endif

	for(int i=0;i<4096;i++)
		xil_printf("B[%d]=%d\r\n",i,B[i]);

    cleanup_platform();
    return 0;
}

```

运行后由结果可以看到，数组A的值搬到了数组B中。













### 7、神经网络加速器访存模块设计

#### （1）模块结构概述

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E5%8A%A0%E9%80%9F%E5%99%A8%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9D%97.png)



**设计访存模块的意义：** 利用访存模块，可以为卷积池化等计算单元配置参数，而且不需要为所有的计算单元都添加AXI4总线接口，而只需要为访存模块设计一个AXI4接口，用来从DDR读取数据。这样，内部计算单元的数据交互只需要自定义一些握手信号即可，不再需要添加复杂的AXI4总线。

**访存模块的接口：** 

| 读通道（从DDR取数据到计算单元）                            | 方向            |
| ---------------------------------------------------------- | --------------- |
| 读：命令（起始地址，突发长度）                             | Master -> Slave |
| 读：数据返回                                               | Slave -> Master |
| **写通道（将计算单元的结果存储到DDR上）**                  | **方向**        |
| 写：命令（起始地址，突发长度）+数据   ( 共用一条数据通路） | Master -> Slave |

**访存模块简单结构图：** 

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9D%97%E7%AE%80%E5%9B%BE.png)

**读通道结构图：** 

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9D%97%E8%AF%BB%E6%93%8D%E4%BD%9C.png)

**写通道结构图：** 

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9D%97%E5%86%99%E6%93%8D%E4%BD%9C.png)

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E8%AE%BF%E5%AD%98%E6%A8%A1%E5%9D%97%E5%86%99%E6%93%8D%E4%BD%9C%EF%BC%92.png)

**访存模块内部roundrobin仲裁器结构图：**

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E4%BB%B2%E8%A3%81%E5%99%A82.png)

![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E4%BB%B2%E8%A3%81%E5%99%A81.png)



**关于FIFO使用的通俗解释：**

​	FIFO的使用，就相当于要给他人寄一封信，这时我们要把信先送到邮局，然后就可以不用再管了。当邮局凑够一批信之后，会在一个时间点把这些信一起发出去。

​	各个计算模块向DDR写命令或者数据时，先写到FIFO里，然后从FIFO给到AXI4总线上，最终给DDR。当最终传输完成后，会返回一个响应信号（sdp2mcif_wr_rsp_complete）。



#### **（2）具体代码实现**

注：具体代码，见工程axi_mem1

- **访存模块代码说明：** 

mcif_4r_4w.v是顶层模块，主要定义了整个访存模块的接口，并对读模块 mcif_rd_4r 和写模块 mcif_wr_4w 进行实例化。

mcif_rr_arb4.v 是roundrobin仲裁器实现的模块，其内部的子模块为 mcif_arb_comb4.v。

hs_pipe.v 是计算模块与访存模块数据交互的FIFO。

fifo_dff.v 用来记录写通道任务信息，然后依次执行读任务命令。

defines.vh 是宏定义模块

:happy: defines.vh



:happy:  ​mcif_4r_4w.v



:happy: mcif_rd_4r



:happy: mcif_wr_4w



:happy: mcif_rr_arb4.v



:happy: mcif_arb_comb4.v



:happy:  hs_pipe.v 



:happy:  fifo_dff.v





- **仿真模块代码说明：**

AXI_HP_Slave.sv模块是基于AXI4总线的从设备。

:happy:  AXI_HP_Slave.sv



:happy: testbench



:happy: tasks.vh





### 8、池化运算单元设计







































![](/../typora%E5%9B%BE%E7%89%87%E6%80%BB/%E5%8A%A0%E9%80%9F%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png)



